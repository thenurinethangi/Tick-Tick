{"version":3,"file":"index.mjs","names":["defaults: Options","plainTextSelectors: SelectorDefinition[]","html","html!: string","html"],"sources":["../../src/shared/utils/pretty.ts","../../src/shared/utils/to-plain-text.ts","../../src/node/read-stream.ts","../../src/node/render.tsx"],"sourcesContent":["import type { Options, Plugin } from 'prettier';\nimport type { builders } from 'prettier/doc';\nimport * as html from 'prettier/plugins/html';\nimport { format } from 'prettier/standalone';\n\ninterface HtmlNode {\n  type: 'element' | 'text' | 'ieConditionalComment';\n  name?: string;\n  sourceSpan: {\n    start: { file: unknown[]; offset: number; line: number; col: number };\n    end: { file: unknown[]; offset: number; line: number; col: number };\n    details: null;\n  };\n  parent?: HtmlNode;\n}\n\nfunction recursivelyMapDoc(\n  doc: builders.Doc,\n  callback: (innerDoc: string | builders.DocCommand) => builders.Doc,\n): builders.Doc {\n  if (Array.isArray(doc)) {\n    return doc.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));\n  }\n\n  if (typeof doc === 'object') {\n    if (doc.type === 'group') {\n      return {\n        ...doc,\n        contents: recursivelyMapDoc(doc.contents, callback),\n        expandedStates: recursivelyMapDoc(\n          doc.expandedStates,\n          callback,\n        ) as builders.Doc[],\n      };\n    }\n\n    if ('contents' in doc) {\n      return {\n        ...doc,\n        contents: recursivelyMapDoc(doc.contents, callback),\n      };\n    }\n\n    if ('parts' in doc) {\n      return {\n        ...doc,\n        parts: recursivelyMapDoc(doc.parts, callback) as builders.Doc[],\n      };\n    }\n\n    if (doc.type === 'if-break') {\n      return {\n        ...doc,\n        breakContents: recursivelyMapDoc(doc.breakContents, callback),\n        flatContents: recursivelyMapDoc(doc.flatContents, callback),\n      };\n    }\n  }\n\n  return callback(doc);\n}\n\nconst modifiedHtml = { ...html } as Plugin;\nif (modifiedHtml.printers) {\n  const previousPrint = modifiedHtml.printers.html.print;\n  modifiedHtml.printers.html.print = (path, options, print, args) => {\n    const node = path.getNode() as HtmlNode;\n\n    const rawPrintingResult = previousPrint(path, options, print, args);\n\n    if (node.type === 'ieConditionalComment') {\n      const printingResult = recursivelyMapDoc(rawPrintingResult, (doc) => {\n        if (typeof doc === 'object' && doc.type === 'line') {\n          return doc.soft ? '' : ' ';\n        }\n\n        return doc;\n      });\n\n      return printingResult;\n    }\n\n    return rawPrintingResult;\n  };\n}\n\nconst defaults: Options = {\n  endOfLine: 'lf',\n  tabWidth: 2,\n  plugins: [modifiedHtml],\n  bracketSameLine: true,\n  parser: 'html',\n};\n\nexport const pretty = (str: string, options: Options = {}) => {\n  return format(str.replaceAll('\\0', ''), {\n    ...defaults,\n    ...options,\n  });\n};\n","import {\n  convert,\n  type HtmlToTextOptions,\n  type SelectorDefinition,\n} from 'html-to-text';\n\nexport const plainTextSelectors: SelectorDefinition[] = [\n  { selector: 'img', format: 'skip' },\n  { selector: '[data-skip-in-text=true]', format: 'skip' },\n  {\n    selector: 'a',\n    options: { linkBrackets: false, hideLinkHrefIfSameAsText: true },\n  },\n];\n\nexport function toPlainText(html: string, options?: HtmlToTextOptions) {\n  return convert(html, {\n    selectors: plainTextSelectors,\n    wordwrap: false,\n    ...options,\n  });\n}\n","import { Writable } from 'node:stream';\nimport type {\n  PipeableStream,\n  ReactDOMServerReadableStream,\n} from 'react-dom/server.browser';\n\nexport const readStream = async (\n  stream: PipeableStream | ReactDOMServerReadableStream,\n) => {\n  let result = '';\n  // Create a single TextDecoder instance to handle streaming properly\n  // This fixes issues with multi-byte characters (e.g., CJK) being split across chunks\n  const decoder = new TextDecoder('utf-8');\n\n  if ('pipeTo' in stream) {\n    // means it's a readable stream\n    const writableStream = new WritableStream({\n      write(chunk: BufferSource) {\n        // Use stream: true to handle multi-byte characters split across chunks\n        result += decoder.decode(chunk, { stream: true });\n      },\n      close() {\n        // Flush any remaining bytes\n        result += decoder.decode();\n      },\n    });\n    await stream.pipeTo(writableStream);\n  } else {\n    const writable = new Writable({\n      write(chunk: BufferSource, _encoding, callback) {\n        // Use stream: true to handle multi-byte characters split across chunks\n        result += decoder.decode(chunk, { stream: true });\n\n        callback();\n      },\n      final(callback) {\n        // Flush any remaining bytes\n        result += decoder.decode();\n        callback();\n      },\n    });\n    stream.pipe(writable);\n\n    await new Promise<void>((resolve, reject) => {\n      writable.on('error', reject);\n      writable.on('close', () => {\n        resolve();\n      });\n    });\n  }\n\n  return result;\n};\n","import { Suspense } from 'react';\nimport type { Options } from '../shared/options';\nimport { pretty } from '../shared/utils/pretty';\nimport { toPlainText } from '../shared/utils/to-plain-text';\nimport { readStream } from './read-stream';\n\nexport const render = async (node: React.ReactNode, options?: Options) => {\n  const suspendedElement = <Suspense>{node}</Suspense>;\n  const reactDOMServer = await import('react-dom/server').then(\n    // This is beacuse react-dom/server is CJS\n    (m) => m.default,\n  );\n\n  let html!: string;\n  if (\n    Object.hasOwn(reactDOMServer, 'renderToReadableStream') &&\n    typeof WritableStream !== 'undefined'\n  ) {\n    html = await readStream(\n      await reactDOMServer.renderToReadableStream(suspendedElement, {\n        progressiveChunkSize: Number.POSITIVE_INFINITY,\n      }),\n    );\n  } else {\n    await new Promise<void>((resolve, reject) => {\n      const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {\n        async onAllReady() {\n          html = await readStream(stream);\n          resolve();\n        },\n        onError(error) {\n          reject(error as Error);\n        },\n        progressiveChunkSize: Number.POSITIVE_INFINITY,\n      });\n    });\n  }\n\n  if (options?.plainText) {\n    return toPlainText(html, options.htmlToTextOptions);\n  }\n\n  const doctype =\n    '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">';\n\n  const document = `${doctype}${html.replace(/<!DOCTYPE.*?>/, '')}`;\n\n  if (options?.pretty) {\n    return pretty(document);\n  }\n\n  return document;\n};\n"],"mappings":"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"}